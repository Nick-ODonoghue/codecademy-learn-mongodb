<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Learn MongoDB - Codecademy | NickOD.xyz</title>
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet" />
		<link rel="stylesheet" href="reset.css" />
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<main class="wrapper">
			<h1>Codecademy - Learn MongoDB</h1>
			<p>
				Notes taken while going through the
				<a href="https://www.codecademy.com/learn/learn-mongodb">Codecademy Learn MongoDB course</a>
			</p>

			<h2>Introduction to Databases</h2>

			<section>
				<h3>What is a Database?</h3>
				<ul>
					<li>Databases store, modify, and retrieve collections of information electronically.</li>
					<li>
						They enable websites like Codecademy to retain and retrieve large amounts of information in an organized and
						consistent manner.
					</li>
					<li>Benefits of using databases in software development:</li>
					<ol>
						<li>Efficient storage and retrieval of data.</li>
						<li>Data consistency and integrity.</li>
						<li>Data security and access control.</li>
						<li>Scalability for handling large amounts of data.</li>
					</ol>
					<li>Databases are essential for organizing and managing content on websites.</li>
					<li>Different database classifications exist, and understanding them is useful for developers.</li>
				</ul>
			</section>

			<section>
				<h3>Why Databases?</h3>
				<ul>
					<li>Databases are crucial for storing data in various types of software applications.</li>
					<li>They allow for the persistence of important information necessary for application functionality.</li>
					<li>Databases are often represented as a bucket that can store any type of information.</li>
					<img src="./assets/images/representationOfADatabase.png" alt="picture representation of a database" />
					<li>Applications interact with a database through a database management system (DBMS).</li>
				</ul>
			</section>

			<section>
				<h3>Database Management Systems (DBMS)</h3>
				<ul>
					<li>
						DBMS (Database Management System) is the software that encapsulates the database and allows interaction with
						it.
					</li>
					<li>It provides a programming language or graphical interface (GUI) to work with the database.</li>
					<li>DBMS allows storing multiple databases and provides unique features for maintaining data.</li>
					<img src="./assets/images/databaseManagementSystem.png" alt="illostration of a database management system" />
					<li>
						Different types of data can be stored in the database, including strings, numeric data, date and time types,
						booleans, images, and audio files.
					</li>
					<li>Each DBMS has its own implementation and offers advantages and disadvantages.</li>
					<li>Two common types of databases and their associated DBMS are discussed:</li>
					<ol>
						<li>
							Relational databases: Known for storing data in tables with predefined relationships, using SQL for
							manipulation and retrieval.
						</li>
						<li>
							Non-relational databases: Store data in flexible, schema-less formats like key-value pairs, documents, or
							graphs, providing scalability and performance.
						</li>
					</ol>
					<li>The choice of DBMS depends on the specific requirements and use cases of the application.</li>
				</ul>
			</section>

			<section>
				<h3>Relational Databases</h3>
				<ul>
					<li>Relational databases structure data in tabular form with rows and columns.</li>
					<img src="./assets/images/relationalDatabaseStructure.png" alt="relational database structure" />
					<li>Data is organized and stored in tables, with each table representing a specific entity or concept.</li>
					<img src="./assets/images/songsTable.png" alt="song table" />
					<img src="./assets/images/albumsTable.png" alt="album table" />
					<img src="./assets/images/artistsTable.png" alt="artist table" />
					<li>Relationships between tables can be defined, such as "one-to-one," "one-to-many," and "many-to-many."</li>
					<li>
						A music streaming website might have tables for albums, songs, and artists, with relationships established
						between them.
					</li>
					<img src="./assets/images/tableRelationships.png" alt="relationships between tables" />
					<li>
						A relationship between the Songs and Albums table. A song “belongs” to an album via the album_id field.
					</li>
					<li>
						A relationship between the Albums and Artists table. An album “belongs” to an artist via the artist_id
						field.
					</li>
					<li>Relational databases have a pre-defined schema, determined before inserting any data.</li>
					<li>Developers interact with relational databases using SQL (Structured Query Language).</li>
					<li>Relational databases are often referred to as SQL databases due to their reliance on SQL.</li>
					<li>They are managed by a Relational Database Management System (RDBMS).</li>
					<li>Popular RDBMS options include PostgreSQL and MySQL.</li>
					<li>
						Relational databases have unique disadvantages at an enterprise level, including cost and space
						considerations for large data sets.
					</li>
				</ul>
			</section>

			<section>
				<h3>Non-Relational Databases</h3>
				<ul>
					<li>Non-relational databases, also known as NoSQL databases, do not follow the relational model.</li>
					<li>They store data in formats other than tables and do not strictly rely on relationships.</li>
					<li>
						Different types of non-relational databases include document databases, graph databases, and key-value
						databases.
					</li>
					<li>
						Non-relational databases specialize in storing unstructured data that doesn't fit neatly into rows and
						columns.
					</li>
					<li>Example: Music database stored in a document database using JSON format.</li>
					<img src="./assets/images/nonRelationalDatabase.png" alt="a non-relational database visual example" />
					<li>
						Non-relational databases offer flexibility and scalability, allowing for flexible schemas and easy
						adaptation to changing application needs.
					</li>
					<li>Each NoSQL database has its own custom query language instead of a standardized language like SQL.</li>
					<li>
						Disadvantages of non-relational databases include potential difficulties in maintaining and tracking
						unstructured data and the need to learn different query languages for each database.
					</li>
				</ul>
			</section>

			<section>
				<h3>Review: Introduction to Databases</h3>
				<ul>
					<li>Databases:</li>
					<ol>
						<li>
							Databases are systems that store, modify, and access structured collections of information electronically.
						</li>
						<li>
							Database Management Systems (DBMS) allow developers to communicate via code or a graphical user interface
							with a database.
						</li>
						<li>
							Databases can store a wide range of data types, including text, numbers, dates and times, and files of
							various types.
						</li>
					</ol>
					<li>Relational Databases:</li>
					<ol>
						<li>
							Relational databases, a common database class, organize data into tables of rows and columns of
							information and rely on relationships to organize data.
						</li>
						<li>A relational database schema is typically pre-defined before data is entered.</li>
						<li>
							All relational databases use SQL to allow developers to communicate with the database using a common
							language.
						</li>
						<li>
							Relational databases can be costly to set up and scale. Performance and cost are big factors in using a
							relational database in an application.
						</li>
					</ol>
					<li>Non-Relational Databases:</li>
					<ol>
						<li>
							Non-relational databases, another common database class, refer to any database that does not follow the
							relational model.
						</li>
						<li>
							Non-relational databases typically have a more flexible schema and are more easily scaled than relational
							databases. However, the unstructured nature of the data can make it difficult to maintain, and each
							non-relational database has its own query language.
						</li>
					</ol>
				</ul>
				<p>Useful Links:</p>
				<li>
					<a href="https://en.wikipedia.org/wiki/Database#Classification"
						>Comprehensive list of database classifications</a
					>
				</li>
				<li>
					<a href="https://www.mongodb.com/nosql-explained/nosql-vs-sql">A deeper dive into NoSQL vs SQL</a>
				</li>
				<br />
				<li>
					<a href="https://www.codecademy.com/learn/learn-mongodb/modules/database-basics/cheatsheet"
						>Database Basics - Cheatsheet</a
					>
				</li>
			</section>

			<h2>Introduction to No-SQL</h2>

			<section>
				<h3>Introduction to No-SQL</h3>
				<ul>
					<li>NoSQL is an alternative to relational databases.</li>
					<li>NoSQL stands for "not-only SQL" or "non-relational" databases.</li>
					<li>NoSQL databases store data differently from relational databases.</li>
					<li>NoSQL encompasses various database technologies.</li>
				</ul>
			</section>

			<section>
				<h3>Arriving at No-SQL</h3>
				<ul>
					<li>Relational databases have been around since the late 1960s and have been widely used.</li>
					<li>
						With the increase in data size and complexity, developers sought a more flexible and scalable database
						solution.
					</li>
					<li>NoSQL databases emerged as an alternative to address these needs.</li>
					<li>
						Developers choose NoSQL databases for reasons like flexibility, scalability, handling large and diverse
						datasets, unstructured data support, high performance, and distributed/cloud environments.
					</li>
					<li>NoSQL databases offer flexibility in schema design and can accommodate evolving data requirements.</li>
				</ul>
			</section>

			<section>
				<h3>Is No-SQL the Right Option?</h3>
				<ul>
					<li>NoSQL databases offer distinct advantages over relational databases.</li>
					<li>Benefits of NoSQL databases:</li>
					<ol>
						<li>
							Scalability: Designed for handling massive datasets distributed across multiple servers and locations.
						</li>
						<li>
							Flexibility: No schema requirement allows handling of unstructured or semi-structured data in different
							formats.
						</li>
						<li>
							Developer Experience: Less organizational overhead allows developers to focus more on using the data.
						</li>
					</ol>
					<li>Drawbacks of NoSQL databases:</li>
					<ol>
						<li>Data Integrity: NoSQL databases prioritize availability and scalability over strict data integrity.</li>
						<li>
							Language Standardization: Each NoSQL database often has its unique language for setup, management, and
							querying.
						</li>
					</ol>
				</ul>
			</section>

			<section>
				<h3>Types of No-SQL Databases</h3>
				<ul>
					<li>There are four common types of NoSQL databases.</li>
					<li>Key-Value Databases:</li>
					<ol>
						<li>Organize data using key-value pairs.</li>
						<li>Keys and values can be any type of data, but keys must be unique.</li>
						<li>Ideal for fast queries and simple data.</li>
					</ol>
					<img src="./assets/images/keyValueDatabase.png" alt="key value database" />
					<li>Examples: Amazon DynamoDB, Redis.</li>
					<li>Document database:</li>
					<ol>
						<li>Document-based databases store data in hierarchical structures.</li>
						<li>They support document formats like JSON, BSON, XML, and YAML.</li>
						<li>
							The document-based model extends the key-value database and allows querying based on more than just unique
							keys.
						</li>
						<li>Documents are flexible and can evolve to fit application needs, including modeling relationships.</li>
					</ol>
					<li>Example: Storing product information for customers in an e-commerce store.</li>
					<img src="./assets/images/documentDatabase.png" alt="document database" />
					<li>MongoDB is a popular option for working with document databases.</li>
					<li>Graph Databases:</li>
					<ol>
						<li>Graph databases store data using a graph structure with nodes and edges.</li>
						<li>Nodes represent entities, while edges represent relationships between nodes.</li>
						<li>
							Graph databases simplify the setup, management, and querying of relationships compared to relational
							databases.
						</li>
						<li>They are useful for scenarios such as building recommendation engines based on user searches.</li>
					</ol>
					<li>Example: Establishing relationships between items to create recommendations in an e-commerce store.</li>
					<img src="./assets/images/graphDatabase.png" alt="graph database" />
					<li>Neo4j is a popular option for working with graph databases.</li>
					<li>Column Oriented Databases:</li>
					<ol>
						<li>
							Column-oriented NoSQL databases store data as columns rather than rows, aiming to provide faster read
							speeds.
						</li>
						<li>Data is aggregated quickly for specific columns, making it efficient for analytical queries.</li>
						<li>Column-oriented databases eliminate the need to pull irrelevant data from adjacent rows.</li>
					</ol>
					<li>Example: Analyzing total sales for products by aggregating data from the sales column.</li>
					<img src="./assets/images/columnOrientatedDatabase.png" alt="column oriented database" />
					<li>Amazon's Redshift is a popular option for working with column-oriented databases.</li>
				</ul>
			</section>

			<section>
				<h3>Review: Introduction to No-SQL</h3>
				<ul>
					<li>
						NoSQL stands for “not-only SQL” (also called “non-relational”, or “non-SQL”) and refers to any database that
						stores data in any format other than relational tables.
					</li>
					<li>NoSQL database technology grew in popularity due to datasets growing in size and complexity.</li>
					<li>NoSQL databases may provide flexibility, scalability, and speed advantages.</li>
					<li>
						NoSQL databases experience disadvantages such as lack of data integrity and lack of language standardization
						across different NoSQL databases.
					</li>
					<li>Common types of NoSQL databases include key-value, document, graph, and column-oriented.</li>
				</ul>
			</section>

			<h2>Introduction to MongoDB</h2>

			<section>
				<h3>Introduction</h3>
				<ul>
					<li>Modern databases allow us to store, organize, and retrieve data.</li>
					<li>Two main classes of databases: relational (SQL) and non-relational (NoSQL).</li>
					<li>Relational databases store data using tables (rows and columns) and work well for organized data.</li>
					<li>Non-relational databases store data in various ways and work well for unstructured data.</li>
					<li>MongoDB is one of the most popular document databases.</li>
				</ul>
			</section>

			<section>
				<h3>What is MongoDB?</h3>
				<ul>
					<li>MongoDB is a database system released in 2009 and regularly updated.</li>
					<li>It uses the document model to store data.</li>
					<li>The document model stores data in documents and collections.</li>
					<li>Data inside documents is typically stored in hierarchical structures like JSON, BSON, and YAML.</li>
					<li>
						In contrast to relational databases, MongoDB stores data in individual documents rather than rows in tables.
					</li>
					<li>Each document can have a unique set of fields.</li>
					<li>Documents are stored inside collections.</li>
					<li>MongoDB is known for its flexibility and developer-friendly features.</li>
					<img src="./assets/images/relationalDBvsDocumentDB.png" alt="relational database vs a document database" />
				</ul>
			</section>

			<section>
				<h3>Advantages of Using MongoDB</h3>
				<ul>
					<li>Flexibility and Scalability:</li>
					<ol>
						<li>
							Flexible data storage: Document databases like MongoDB allow for flexible storage of data. Unlike
							relational databases where changing a column in a table affects all entries, changes to a single document
							in MongoDB have no impact on other documents. This flexibility enables easy adaptation of the database to
							evolving application requirements.
						</li>
						<li>
							Scalability: As applications grow, the database must be able to handle increasing amounts of data. MongoDB
							offers various user-friendly options for scaling the database to accommodate growth. This ensures that the
							database can handle larger workloads and increasing demands without compromising performance.
						</li>
					</ol>
					<li>Developer-Friendly:</li>
					<ol>
						<li>
							MongoDB databases support a variety of different use-cases. To name a few, MongoDB can be used to build
							web, mobile, and desktop applications. MongoDB also has features that support data analytics and data
							visualization.
						</li>
						<li>
							Given MongoDB’s popularity, a large community has formed around the technology. This means there are a
							plethora of resources (e.g., forums, articles, conferences) available for developers at any level.
						</li>
						<li>
							MongoDB has a significant amount of detailed documentation and educational tools (like MongoDB University)
							to help developers learn about all of MongoDB’s unique features.
						</li>
					</ol>
					<li>Diverse Cloud Tooling:</li>
					<ol>
						<li>
							MongoDB Atlas: MongoDB's multi-cloud database service that allows developers to easily create, manage, and
							deploy MongoDB databases in the cloud. It eliminates the need for local MongoDB setup and provides an
							online dashboard for database management.
						</li>
						<li>
							MongoDB Realm: A cloud offering by MongoDB that enables developers to quickly build applications
							integrated with MongoDB. Realm supports various use cases, including mobile, internet-of-things (IoT), and
							desktop applications. It allows for database creation on mobile devices, seamless data synchronization,
							and complex tasks like authentication.
						</li>
					</ol>
				</ul>
			</section>

			<section>
				<h3>Review: Introduction to MongoDB</h3>
				<ul>
					<li>
						MongoDB is a NoSQL document database. This means that data entries in the database are stored inside
						documents within collections.
					</li>
					<li>Choosing to use MongoDB has some key benefits:</li>
					<ol>
						<li>Flexibility and Scalability</li>
						<li>Developer Friendly</li>
						<li>Diverse Cloud Tooling</li>
					</ol>
				</ul>
				<br />
				<li>
					<a href="https://www.codecademy.com/learn/learn-mongodb/modules/introduction-to-mongodb/cheatsheet"
						>Introduction to MongoDB - Cheatsheet</a
					>
				</li>
			</section>

			<h2>MongoDB & Data</h2>

			<section>
				<h3>Collections & Documents</h3>
				<ul>
					<li>MongoDB uses the document model to store data.</li>
					<li>Data in MongoDB is organized into collections, which are subsets of the database.</li>
					<li>Each collection contains individual records called documents.</li>
					<li>Documents store information about specific entities.</li>
					<li>Collections group together documents with similar information.</li>
					<li>MongoDB databases consist of multiple collections assembled to store data for a specific use case.</li>
					<li>
						In the example of a camera store, the database would have collections for purchase data, inventory, and
						customer information.
					</li>
					<img src="./assets/images/mongoDBDatabase.png" alt="mongodb database" />
					<li>Documents within the customer collection would store personal information about each customer.</li>
					<li></li>
					<li></li>
				</ul>
			</section>

			<section>
				<h3>Data as JSON</h3>
				<ul>
					<li>JSON (Javascript Object Notation) is a text format for storing data.</li>
					<li>JSON stores data as key-value pairs within curly braces.</li>
					<img src="./assets/images/JSONFormat.png" alt="JSON example" />
					<li>
						MongoDB and various online resources also refer to these pairs as “field-value” or “name-value” pairs.
					</li>
					<li>Fields are unique identifiers for data points, indicating what kind of data is being stored.</li>
					<li>Values are the actual data points associated with each field.</li>
					<li>JSON supports various data types such as strings, numbers, arrays, and nested data.</li>
					<li>JSON is readable and easily editable by humans and computers.</li>
					<li>However, there are drawbacks to using JSON as a primary storage format in databases:</li>
					<ol>
						<li>JSON is computationally inefficient as parsing text takes time.</li>
						<li>It is not storage-efficient due to longer descriptive field names taking up more space.</li>
						<li>JSON has limited support for data types, lacking native support for dates.</li>
					</ol>
					<li>While JSON has advantages, it is not ideal as the primary storage format for databases.</li>
				</ul>
			</section>

			<section>
				<h3>BSON - MongoDB’s Storage Format</h3>
				<ul>
					<li>BSON (Binary JavaScript Object Notation) is MongoDB's storage format for data.</li>
					<img src="./assets/images/BSONExample.png" alt="BSON example" />
					<li>BSON differs from JSON in three ways:</li>
					<ol>
						<li>BSON is not human-readable.</li>
						<li>BSON is more efficient in terms of storage.</li>
						<li>BSON supports additional data formats not found in JSON, such as dates.</li>
					</ol>
					<li>
						BSON allows MongoDB to bridge the gap between JSON's flexibility and readability and the performance
						requirements of a large database.
					</li>
					<li>
						MongoDB stores data internally as BSON, but developers can interact with and manipulate the data using JSON.
					</li>
					<li>This approach enables efficient data storage and provides a good developer experience.</li>
				</ul>
			</section>

			<section>
				<h3>Review: MongoDB & Data</h3>
				<ul>
					<li>
						A MongoDB instance can contain many databases, and within a database are collections of similar data.
						Collections contain individual records called documents that are stored as field-value pairs.
					</li>
					<li>
						JSON is a human-readable but inefficient format for storing data; conversely, BSON is not human-readable but
						is highly efficient.
					</li>
					<li>
						MongoDB users can easily store and manipulate data as JSON – even though internally, that data is stored as
						BSON.
					</li>
				</ul>
				<p>Useful Links:</p>
				<li>
					<a
						href="https://www.mongodb.com/json-and-bson?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>SON and BSON Guide</a
					>
				</li>
				<li>
					<a
						href="https://www.mongodb.com/basics/bson?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>Explaining BSON with Examples</a
					>
				</li>
			</section>

			<section>
				<h3>MongoDB Data Modeling Basics</h3>
				<ul>
					<li>A data model provides structure and organization to complex sets of information.</li>
					<li>A well-designed data model enhances database usability and efficiency.</li>
					<li>Two different data models can have different implications for usability and efficiency.</li>
					<li>
						Model A: Offers better data integrity and lower storage usage, but querying may take longer since data is
						spread across multiple collections.
					</li>
					<img src="./assets/images/multipleCollectionDataModel.png" alt="multi collection data model" />
					<li>Model B: Provides performance benefits with faster queries, but may have duplicated data.</li>
					<img src="./assets/images/singleCollectionDataModel.png" alt="single collection data model" />
					<li>Choosing the appropriate data model is vital for optimizing data storage and retrieval.</li>
					<li>Applications may require data model refactoring as database requirements evolve.</li>
					<li>
						Selecting the most suitable data model for your application is crucial for ensuring efficient data
						organization and retrieval.
					</li>
				</ul>
			</section>

			<section>
				<h3>Modeling Relationships in MongoDB</h3>
				<ul>
					<li>Relationships between data are important when considering the structure of collections in MongoDB.</li>
					<li>
						Using the example of a car database, a car document contains attributes like color and size, but may also
						have information about the car's engine.
					</li>
					<li>
						The engine is a separate entity with its own attributes, and it wouldn't be appropriate to make engine_power
						an attribute of the car.
					</li>
					<li>
						It's necessary to determine the relationship between the car data and the engine in the context of the
						entire database.
					</li>
					<li>
						The challenge in data modeling is to decide how to represent the engine as a separate entity and define its
						relationships to the car and across the collection.
					</li>
					<li>MongoDB offers two options for establishing relationships: embedded documents or references.</li>
				</ul>
			</section>

			<section>
				<h3>Embedded Documents</h3>
				<ul>
					<li>Embedded documents allow us to nest related data directly inside a document in MongoDB.</li>
					<li>Nested documents are called sub-documents.</li>
					<img src="./assets/images/embeddedDocumentModel.png" alt="embedded document example" />
					<li>Embedded documents are denormalized, meaning related data is stored together in a single collection.</li>
					<li>
						A good use case for embedded documents is modeling one-to-one relationships, where one entity contains
						another. For example, a car document can have an embedded sub-document for the engine.
					</li>
					<li>
						Another use case is modeling one-to-many relationships, where one entity maps to many sub-entities. For
						example, a car owner document can have multiple embedded car sub-documents representing the cars they own.
					</li>
				</ul>
			</section>

			<section>
				<h3>References</h3>
				<ul>
					<li>References in MongoDB allow us to create links between data to establish relationships.</li>
					<li>With references, data is split into multiple documents and linked using identifiers.</li>
					<img src="./assets/images/references.png" alt="reference data model example" />
					<li>
						In the car and engine example, the engine data is stored in a separate collection and linked to the car
						document using the engine_id field.
					</li>
					<li>
						This type of data model is called a normalized data model and resembles how relationships are created in
						relational databases.
					</li>
					<li>
						References are useful for modeling many-to-many relationships, where many instances of one entity can be
						mapped to many instances of another entity.
					</li>
					<li>
						An example is the relationship between car rentals and individuals renting cars, where a car can be rented
						by multiple individuals and an individual can rent multiple cars.
					</li>
				</ul>
			</section>

			<h2>Choosing the Right Model</h2>

			<section>
				<h3>
					Case A: A time management application that stores one user per task. We want to store details about the task,
					such as the task name, the task due date, and the user assigned to the task (and their associated details).
					There can only be one person assigned to each task.
				</h3>
				<ul>
					<li>In the given scenario, we are modeling a one-to-one relationship between a task and a user.</li>
					<li>
						To retrieve the user data along with the task details in one query, it is preferable to use an embedded
						document.
					</li>
					<img src="./assets/images/oneToOneEmbedded.png" alt="one to one embedded document" />
					<li>
						The document represents a task with the task name, due date, and the assignee's information embedded within
						it.
					</li>
					<li>
						The assignee information includes the name, role, and contact details of the user assigned to the task.
					</li>
					<li>
						By using an embedded document, we can retrieve all the necessary information for the task and the assignee
						in a single query.
					</li>
				</ul>
			</section>

			<section>
				<h3>
					Case B: A contact information management application that can store multiple addresses per user. The
					application would store important details for the person such as their name, as well as their associated
					addresses.
				</h3>
				<ul>
					<li>
						In this case, we are modeling a one-to-many relationship between a user and their associated addresses.
					</li>
					<li>There are two ways to implement the data model: using embedded documents or references.</li>
					<li>
						If we choose to use embedded documents, each user document would contain an array field called addresses,
						where each element represents an address with a label and its corresponding details.
					</li>
					<img src="./assets/images/case2Embedded.png" alt="embedded screenshot 1" />
					<li>
						Using embedded documents is preferable when there are frequent queries on the addresses field, as we can
						retrieve the address information directly from the user document.
					</li>
					<li>
						However, if multiple users start sharing the same address, the embedded documents may lead to repetition and
						increased storage.
					</li>
					<img src="./assets/images/case2Embedded2.png" alt="embedded screenshot 2" />
					<li>
						In such cases, using references is recommended. The addresses would be stored in a separate addresses
						collection, with each address having a unique ID.
					</li>
					<img src="./assets/images/referenceAddress.png" alt="reference address example" />
					<li>
						The user documents would then include an array field called addresses, containing the unique IDs of the
						associated address documents.
					</li>
					<img src="./assets/images/referenceUser.png" alt="reference user example" />
					<li>
						By using references, we avoid the repetition of address details and maintain a more efficient data model.
					</li>
					<li>
						The choice between embedded documents and references depends on factors such as the frequency of accessing
						address information and the size of the data, which should be considered when making the data modeling
						decision.
					</li>
				</ul>
			</section>

			<section>
				<h3>
					Case C: A school registration application that manages multiple students. Each student can be in multiple
					classes. Each class record can easily identify which students are registered and each student record can
					quickly find any associated classes.
				</h3>
				<ul>
					<li>In this application, we have many students sharing a relationship with many classes.</li>
					<li>Here, we need to model a many-to-many relationship.</li>
					<li>In this case, references might be preferred.</li>
					<img src="./assets/images/referenceStudent.png" alt="reference student example" />
					<img src="./assets/images/referenceClass.png" alt="reference classes example" />
				</ul>
			</section>

			<section>
				<h3>Review: MongoDB Data Modeling Basics</h3>
				<ul>
					<li>Data modeling is the practice of developing an organizational structure for the data in our database.</li>
					<li>
						Choosing a data model can have lasting implications on the database and its long-term performance,
						maintainability, and usability.
					</li>
					<li>
						Embedded documents and references are two of the most common ways to model data. These two methods help
						define the relationships between the data in collections.
					</li>
					<li>
						Reference-based data models are normalized; they use links inside of the data (typically via the _id field)
						to create relationships.
					</li>
					<li>
						Embedded data models are denormalized; they use nested documents inside of collections to create
						relationships.
					</li>
				</ul>
				<p>Useful Links:</p>
				<li>
					<a
						href="https://www.mongodb.com/docs/manual/core/data-modeling-introduction/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>Data Modeling Introduction</a
					>
				</li>
				<li>
					<a
						href="https://www.mongodb.com/docs/manual/tutorial/model-embedded-one-to-one-relationships-between-documents/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>Model One-to-One Relationships with Embedded Documents</a
					>
				</li>
				<li>
					<a
						href="https://www.mongodb.com/docs/manual/tutorial/model-embedded-one-to-many-relationships-between-documents/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>Model One-to-Many Relationships with Embedded Documents</a
					>
				</li>
				<li>
					<a
						href="https://www.mongodb.com/docs/manual/tutorial/model-referenced-one-to-many-relationships-between-documents/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>Model One-to-Many Relationships with References</a
					>
				</li>
				<li>
					<a href="https://learn.mongodb.com/courses/m320-mongodb-data-modeling"
						>MongoDB University Data Modeling Course</a
					>
				</li>
			</section>

			<h2>MongoDB CRUD I - Finding Documents</h2>

			<section>
				<h3>Browsing and Selecting Collections</h3>
				<ul>
					<li>
						To list all existing databases, use the command "show dbs". This will display a list of databases in the
						current MongoDB instance, along with their respective disk space usage.
					</li>
					<img src="./assets/images/showDBCommand.png" alt="example output of show db command" />
					<li>If you would like to list all collections within the DB you can use the "show collections" command</li>
					<li>
						To navigate to a specific database, use the command "use dbNameHere". For example, if you want to work with
						the e-commerce database, you would run "use online_plant_shop". This command will switch you to the
						specified database, and if it doesn't exist, MongoDB will create it.
					</li>
					<img src="./assets/images/useDBCommand.png" alt="example output of use DB command" />
					<li>
						After executing the use command, the terminal prompt will show the name of the current database you're
						working with, indicated by the > symbol. For instance, it will change from test> to online_plant_shop>.
					</li>
					<li>
						If you want to check the name of the currently selected database, use the command "db". This will display
						the name of the database you are currently using.
					</li>
				</ul>
			</section>

			<section>
				<h3>Introduction to Querying</h3>
				<ul>
					<li>Persistence in databases refers to the ability to store data that is stable and enduring.</li>
					<li>
						CRUD is an acronym for the four essential functions of a persistent database: create, read, update, and
						delete.
					</li>
					<li>Querying is the process of requesting data from a database.</li>
					<li>The focus of this lesson is on reading data (the "R" in CRUD) from a MongoDB database.</li>
					<li>To read data from MongoDB, we need to query the database.</li>
					<li>The most common way to query data in MongoDB is by using the .find() method.</li>
					<li>The syntax for the .find() method is db.collectionNameHere.find().</li>
					<li>The .find() method is called on a specific collection.</li>
					<li>Calling .find() without arguments will match all documents in the specified collection.</li>
					<li>
						When the query is successful, MongoDB returns a cursor, which is an object that points to the matched
						documents.
					</li>
					<li>
						MongoDB uses cursors to return query results in batches, as queries can potentially match a large number of
						documents.
					</li>
					<li>
						When querying collections with the .find() method, MongoDB returns the first set of matching documents.
					</li>
					<li>To access the next batch of documents, the it keyword (short for iterate) can be used.</li>
				</ul>
			</section>

			<section>
				<h3>Querying Collections</h3>
				<ul>
					<li>
						To find specific documents in a collection, we can pass a query as the first argument to the .find() method.
					</li>
					<li>The query argument is formatted as a document with field-value pairs that we want to match.</li>
					<img src="./assets/images/findWithParameters.png" alt="find method with parameters" />
					<li>We can have as many field-value pairs as we want in our query.</li>
					<img src="./assets/images/findWithMultipleParameters.png" alt="multiple parameters" />
					<li>Query fields and their associated values are case and space sensitive.</li>
					<li>
						The .find() method uses the implicit equality operator, $eq, to match documents based on the specified field
						and value.
					</li>
					<li>We can also explicitly include the equality operator in our query document using the syntax:</li>
					<li>
						However, MongoDB handles implicit equality by default, so we can use the shorthand syntax for basic queries.
					</li>
					<li>
						In the upcoming exercises, we will learn about other operators that can be used to specify ranges and other
						criteria for matching documents in our queries.
					</li>
				</ul>
			</section>

			<section>
				<h3>Querying Embedded Documents</h3>
				<ul>
					<li>
						MongoDB allows us to embed sub-documents directly within a parent document to establish relationships
						between data.
					</li>
					<li>Sub-documents are nested documents that can be accessed using dot notation.</li>
					<img src="./assets/images/subDocuments.png" alt="sub documents" />
					<li>To query on fields in embedded documents, we use the syntax:</li>
					<img src="./assets/images/subDocumentQuery.png" alt="sub document query example" />
					<li>
						We must use the parent field (the name of the field wrapping the embedded document) followed by the dot (.)
						notation and the embedded field we are looking for.
					</li>
					<li>The parent and embedded fields should be wrapped in quotation marks.</li>
					<li>When querying embedded documents, we can access arrays of embedded documents as well.</li>
					<li>For example, to find a document with a specific model name, we can use:</li>
					<img src="./assets/images/embeddedDocumentArray.png" alt="embedded document array accessing" />
					<li>This query will return the document that matches the specified model name.</li>
				</ul>
			</section>

			<section>
				<h3>Comparison Operators: $gt and $lt</h3>
				<ul>
					<li>
						MongoDB provides comparison query operators that allow us to match documents based on measures of equality.
					</li>
					<li>
						The greater than operator, $gt, is used to match documents where the value for a particular field is greater
						than a specified value.
					</li>
					<img src="./assets/images/greaterThanQuery.png" alt="greater than query" />
					<li>
						The greater than or equal to operator, $gte, can be used to match documents where the value is greater than
						or equal to the specified value.
					</li>
					<li>
						The less than operator, $lt, is used to match documents where the value for a particular field is less than
						a specified value.
					</li>
					<img src="./assets/images/lessThanQuery.png" alt="less than query" />
					<li>
						The less than or equal to operator, $lte, can be used to match documents where the value is less than or
						equal to the specified value.
					</li>
					<li>Comparison operators can be used with any data type.</li>
				</ul>
			</section>

			<section>
				<h3>Sorting Documents</h3>
				<ul>
					<li>MongoDB allows us to sort query results by specific fields or sets of fields.</li>
					<li>To sort documents, we use the .sort() method appended to the query.</li>
					<li>
						The .sort() method takes a document as an argument, specifying the fields to sort by and their respective
						sort order.
					</li>
					<li>
						The sort order values can be 1 or -1. A value of 1 sorts the field in ascending order, while -1 sorts it in
						descending order.
					</li>
					<img src="./assets/images/sortingQuery.png" alt="sorting query example" />
					<li>
						For datetime and string values, a value of 1 sorts in chronological or alphabetical order, respectively.
					</li>
					<li>
						Sorting on fields with duplicate values may result in different orderings of documents with those values in
						subsequent queries.
					</li>
					<li>
						Additional fields can be specified for more consistent sorting. For example: db.records.find().sort({
						"release_year": 1, "artist": 1 });
					</li>
					<img src="./assets/images/sortingQueryTwoParameters.png" alt="sorting query with two parameters" />
				</ul>
			</section>

			<section>
				<h3>Query Projections</h3>
				<ul>
					<li>
						MongoDB allows us to specify the exact fields we want to include or exclude in our query results using
						projections.
					</li>
					<li>Projections are specified as a second argument to the .find() method, using a projection document.</li>
					<li>In the projection document, fields can have a value of 1 to include them or 0 to exclude them.</li>
					<img src="./assets/images/queryProjection.png" alt="query projections" />
					<li>
						Projections help us retrieve only the necessary data from documents, especially when dealing with large or
						complex structures.
					</li>
					<li>If a field is not explicitly excluded or included, it is included by default in the query result.</li>
					<li>It's possible to exclude the _id field by setting its value to 0 in the projection document.</li>
					<img src="./assets/images/queryProjectionexcluding.png" alt="query excluding the id field" />
					<li>To exclude multiple fields, assign a value of 0 to each field in the projection document.</li>
					<li>
						Inclusion and exclusion statements cannot be combined in a single projection document, except for the _id
						field.
					</li>
				</ul>
			</section>

			<section>
				<h3>Review: MongoDB CRUD I - Finding Documents</h3>
				<ul>
					<li>We can view a list of all our databases by running the show dbs command.</li>
					<li>
						We can navigate to a particular database, or see which database we are currently using with the use "db",
						and db commands, respectively.
					</li>
					<li>
						We can use the .find() method to query a collection. Excluding a query argument matches all documents from
						the collection.
					</li>
					<li>We can match documents on particular field values by passing a query argument to the .find() method.</li>
					<li>
						When a collection’s record has an embedded document, we can query the fields inside of it using dot notation
						(.) and wrapping the fields in quotation marks.
					</li>
					<li>
						The $gt and $lt comparison operators allow our query to match documents where the value for a particular
						field is greater than or less than a given value, respectively.
					</li>
					<li>
						We can use the .sort() method to sort our query results by a particular field in ascending or descending
						order.
					</li>
					<li>
						We can include a projection in our query to include or exclude certain fields from our returned documents.
					</li>
					<li>
						In addition to the methods and operators we’ve covered in this lesson, MongoDB provides us with even more
						syntax that can be useful to us when performing queries:
					</li>
					<ol>
						<li>The .count() method returns the number of documents that match a query.</li>
						<li>
							The .limit() method can be chained to the .find() method, and specifies the maximum number of documents a
							query will output.
						</li>
						<li>
							The $exists operator can be included in a query filter to only match documents that contain the given
							field.
						</li>
						<li>The $ne operator helps check if a field is not equal to a specified value.</li>
						<li>The $and and $or operators help perform AND or OR logic operators.</li>
						<li>
							Lastly, if you are looking for a way to make query outputs look a bit more “pretty”, you can use the
							.pretty() method!
						</li>
					</ol>
				</ul>
			</section>

			<h2>MongoDB CRUD I - Querying on Array Fields</h2>

			<section>
				<h3>Querying for an Entire Array</h3>
				<ul>
					<li>MongoDB allows us to query documents based on array fields.</li>
					<li>We can use the .find() method to filter documents based on an array field.</li>
					<li>The query argument includes the field and the array we want to match.</li>
					<img src="./assets/images/queryingForArray.jpg" alt="querying for an array" />
					<li>
						The query matches documents where the specified array field contains exactly the same values as specified in
						the query, in the same order.
					</li>
					<li>Additional values in the array or a different order will not result in a match.</li>
					<li>The query returns documents that meet the array matching criteria.</li>
				</ul>
			</section>

			<section>
				<h3>Matching Individual Array Elements</h3>
				<ul>
					<li>MongoDB allows us to match individual elements within an array when querying.</li>
					<li>We can use the .find() method to search for documents based on a specific array element.</li>
					<li>Instead of providing the entire array as the query argument, we provide the value we want to match.</li>
					<img src="./assets/images/matchingIndividualArrayElements.jpg" alt="matching individual array elements" />
					<li>
						The query matches documents where the specified array field contains the specified value, regardless of
						other elements in the array.
					</li>
					<li>The order of elements in the array does not matter.</li>
					<li>The query returns documents that meet the array element matching criteria.</li>
				</ul>
			</section>

			<section>
				<h3>Matching Multiple Array Elements with $all</h3>
				<ul>
					<li>
						The $all operator is used to match documents where an array field includes all the specified elements,
						regardless of the order.
					</li>
					<li>It allows for querying array fields that contain multiple values simultaneously.</li>
					<img src="./assets/images/matchingMultipleArrayElements.jpg" alt="matching multiple array elements" />
					<li>
						When using $all, MongoDB matches documents where the specified array field contains all the elements
						provided in the query, irrespective of the order of the elements.
					</li>
					<li>
						The $all operator returns documents that contain additional elements in the array field, along with the
						specified elements.
					</li>
				</ul>
			</section>

			<section>
				<h3>Querying on Compound Filter Conditions</h3>
				<ul>
					<li>
						In addition to exact matches and individual elements, you can use comparison operators to query array fields
						based on conditions or ranges.
					</li>
					<li>
						Comparison operators like $gte (greater than or equal to), $lte (less than or equal to), $gt (greater than),
						and $lt (less than) can be used to specify the conditions.
					</li>
					<img src="./assets/images/compoundFilterOperators.jpg" alt="compound filter conditions" />
					<li>
						You can combine multiple conditions to create compound queries using logical operators like $and and $or.
					</li>
					<li>
						Compound queries allow you to find documents where array elements meet multiple criteria, even if different
						elements satisfy different conditions.
					</li>
					<li>
						The query result will include documents where at least one array element satisfies the specified criteria.
					</li>
				</ul>
			</section>

			<section>
				<h3>Querying for all conditions with $elemMatch</h3>
				<ul>
					<li>The $elemMatch operator is used to specify multiple criteria on the elements of an array field.</li>
					<li>
						It ensures that the returned documents have at least one array element that satisfies all the specified
						criteria.
					</li>
					<li>
						When using $elemMatch, the conditions specified inside it are treated as a whole and must all be satisfied
						by the same array element.
					</li>
					<img src="./assets/images/elemMatchOperator.jpg" alt="elemMatch operator" />
					<li>
						The $elemMatch operator can be used with other query operators, such as comparison operators, to create
						complex conditions on array elements.
					</li>
					<li>
						The query result will include documents that have at least one array element matching the specified
						criteria, even if other array elements don't match the criteria.
					</li>
				</ul>
			</section>

			<section>
				<h3>Querying an Array of Embedded Documents</h3>
				<ul>
					<li>
						Querying embedded documents in MongoDB is common when dealing with collections that have an array of
						documents.
					</li>
					<li>
						There are two primary ways to query such collections: matching on the entire embedded document or matching
						based on a single field.
					</li>
					<li>
						For an exact match on the entire embedded document, the query must specify the field order and exact field
						values.
					</li>
					<img src="./assets/images/exactMatchEmbededDocument.jpg" alt="exact match on embeded document" />
					<li>The query would return documents that have the exact order and values specified in the query.</li>
					<li>If the field order is different, the query won't return any results.</li>
					<li>Querying based on a single field is also possible using dot notation.</li>
					<img src="./assets/images/singleFieldQuery.jpg" alt="single field query" />
					<li>
						The syntax is the same as querying non-array fields, with the embedded document field and parent document
						field wrapped in quotation marks.
					</li>
					<li>The query would return documents that have an embedded document with the specified year field value.</li>
					<li>These queries can be combined with query operators and multiple conditions using $elemMatch.</li>
				</ul>
				<br />
				<li>
					<a
						href="https://www.mongodb.com/docs/manual/tutorial/query-array-of-documents/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>Query an Array of Embedded Documents</a
					>
				</li>
			</section>

			<section>
				<h3>Review: Querying on Array Fields</h3>
				<ul>
					<li>
						We can query documents for exact array matches by using the .find() method and passing in a query document
						containing the field name, and its array as the value.
					</li>
					<li>
						We can match a single array element by using the .find() method and passing in a query document containing
						the field name, and the element we want to match as its value.
					</li>
					<li>To match multiple elements in an array, we can apply the $all operator to the .find() method.</li>
					<li>
						The $all operator will match any document where the given array field contains all the specified values, in
						any order and regardless of other elements in the array.
					</li>
					<li>
						We can use the .find() method with comparison operators to match documents where the array contains one or
						more elements that satisfy the query conditions in some combination.
					</li>
					<li>
						To match documents where the array contains one or more elements that satisfy all the query conditions, we
						can apply the $elemMatch operator to the .find() method.
					</li>
					<li>
						We can query embedded documents in an array field by querying for either an exact match (with the exact
						order) or by querying for a single field.
					</li>
					<li>MongoDB provides us with even more operators that can be useful to us when querying on array fields:</li>
					<ol>
						<li>The $size operator is used with .find() to match any array with the specified number of elements.</li>
						<li>
							The $in operator can be included in queries to match documents where the field is an array that contains
							at least one element in the specified array.
						</li>
						<li>
							The $nin operator can be included in queries to match documents where the field is an array that contains
							no elements mentioned in the given array.
						</li>
					</ol>
				</ul>
				<br />
				<li>
					<a href="https://www.codecademy.com/learn/learn-mongodb/modules/mongo-db-crud-i/cheatsheet"
						>MongoDB CRUD I - Cheatsheet</a
					>
				</li>
			</section>

			<h2>MongoDB CRUD II Inserting & Updating</h2>

			<section>
				<h3>The _id Field</h3>
				<ul>
					<li>The _id field is present in every document in a MongoDB collection.</li>
					<img src="./assets/images/theIDField.jpg" alt="id field" />
					<li>It is a required field and must be unique for each document.</li>
					<li>If no value is provided for the _id field, MongoDB automatically generates an ObjectId for it.</li>
					<li>
						Developers can choose to specify the _id with a different data type such as a number or random string.
					</li>
					<li>The _id field is immutable, meaning it cannot be updated or changed once assigned to a document.</li>
					<li>The ObjectId is a commonly used data type for the _id field, consisting of a 12-byte value.</li>
					<li>
						Automatically generated ObjectIds contain an embedded timestamp, allowing for rough sorting of documents by
						creation time.
					</li>
					<li>
						The _id field is how MongoDB identifies each unique document when inserting or updating data in a
						collection.
					</li>
					<li></li>
					<li></li>
				</ul>
			</section>

			<section>
				<h3>Inserting a Single Document</h3>
				<ul>
					<li>To insert a single document into a collection, we can use the .insertOne() method.</li>
					<img src="./assets/images/insertOneMethod.jpg" alt="insertOne method" />
					<li>
						The insertOne() method takes the new document as a required parameter and an optional writeConcern
						parameter.
					</li>
					<li>The writeConcern parameter specifies how write requests should be acknowledged by MongoDB.</li>
					<img src="./assets/images/insertAcknowledgment.jpg" alt="insert acknowledgement" />
					<li>
						When a document is successfully inserted, the output includes the acknowledged field with a value of true
						and the insertedId field with the _id of the newly inserted document.
					</li>
					<li>If the specified collection does not exist, MongoDB will create it and insert the document into it.</li>
				</ul>
			</section>

			<section>
				<h3>Inserting Multiple Documents</h3>
				<ul>
					<li>MongoDB's .insertMany() method is used to insert multiple documents into a collection.</li>
					<li>If the specified collection does not exist, MongoDB will create it.</li>
					<img src="./assets/images/insertMany.jpg" alt="insert many example" />
					<li>Parameters:</li>
					<ol>
						<li>An array of documents to be added to the collection.</li>
						<li>writeConcern (optional): Allows specifying how write requests should be acknowledged by MongoDB.</li>
						<li>ordered (optional): Determines whether the insert should be ordered or unordered. Default is true.</li>
					</ol>
					<li>
						With ordered inserts, if a document fails to be inserted, the entire operation stops, and remaining
						documents are not inserted.
					</li>
					<li>Unordered inserts continue even if there are failures and attempt to insert any remaining documents.</li>
					<li>The output includes an insertedIds field, which shows the _id of each inserted document.</li>
					<img src="./assets/images/insertManyOutput.jpg" alt="insert many output" />
				</ul>
			</section>

			<section>
				<h3>Updating a Single Document</h3>
				<ul>
					<li>To update a single document in MongoDB, we use the .updateOne() method.</li>
					<img src="./assets/images/updateOneSyntax.jpg" alt="updateOne syntax" />
					<li>Parameters:</li>
					<ol>
						<li>filter: A document that specifies the selection criteria for the document to update.</li>
						<li>
							update: A document that defines the modifications to be applied to the selected document. MongoDB update
							operators can be used to perform various modifications.
						</li>
						<li>
							options: Additional specifications for the update operation, such as upsert (creates a new document if no
							matching document is found) and writeConcern.
						</li>
					</ol>
					<img src="./assets/images/updateOne.jpg" alt="updateOne example" />
					<li>
						The .updateOne() method updates the first document that matches the filter criteria, even if multiple
						documents match.
					</li>
					<li>The operation returns:</li>
					<img src="./assets/images/updateOneReturned.jpg" alt="returned after updateOne is used" />
					<li>To confirm the update, you can query for the updated document using .findOne():</li>
					<img src="./assets/images/findOneConfirmation.jpg" alt="fondOne confirmation" />
				</ul>
			</section>

			<section>
				<h3>Updates on Embedded Documents and Arrays</h3>
				<ul>
					<li>To update a specific field within an embedded document in MongoDB, we can use dot notation.</li>
					<img src="./assets/images/updatingWithDotNotation.jpg" alt="updating with dot notation" />
					<li>
						The above command successfully targets the width field inside the dimensions embedded document using dot
						notation.
					</li>
					<li>
						MongoDB also allows data to be stored within arrays. To update a value within an array, we can use dot
						notation with the index of the element we want to update.
					</li>
					<img src="./assets/images/updatingWithIndexing.jpg" alt="updating with an index number" />
					<li>
						In the above command, the embedded document's name and the array index (1 in this case) are wrapped in
						quotations.
					</li>
					<li>Note that arrays in MongoDB are zero-indexed, so the first element has an index of 0.</li>
				</ul>
			</section>

			<section>
				<h3>Updating an Array with New Elements</h3>
				<ul>
					<li>MongoDB provides the $push operator to add new elements to the end of an array.</li>
					<li>The $push operator can be used with the .updateOne() method with the following syntax:</li>
					<img src="./assets/images/pushOperator.jpg" alt="push operator" />
					<li>After the update, the document will have the new year added to the array</li>
					<img src="./assets/images/pushOperatorResult.jpg" alt="push operator result" />
					<li>
						If the specified field is absent in the document, the $push operator will add the field as an array and
						include the given value as its element.
					</li>
					<img src="./assets/images/pushOperatorNewField.jpg" alt="push operator with a new field" />
					<li>
						Since the document didn't previously have a country field, running this command will add the new field as an
						array with one element, "Germany":
					</li>
					<img src="./assets/images/pushOperatorNewFieldResult.jpg" alt="new field result" />
				</ul>
			</section>

			<section>
				<h3>Upserting a Document</h3>
				<ul>
					<li>The upsert option is an optional parameter that can be used with update methods like .updateOne().</li>
					<li>
						By default, the upsert option is set to false, which means the update operation will only modify existing
						documents that match the query criteria.
					</li>
					<li>When the upsert option is set to true, the following behavior occurs:</li>
					<ol>
						<li>If there is a matching document, it will be updated with the specified modifications.</li>
						<li>
							If there is no matching document based on the query criteria, a new document will be inserted with the
							specified fields and values.
						</li>
					</ol>
					<li>The syntax for using upsert with .updateOne() is as follows:</li>
					<img src="./assets/images/upsertSyntax.jpg" alt="upsert syntax" />
					<li>Upserting a document in the pets collection for a cat named Luna:</li>
					<img src="./assets/images/upsertingExample.jpg" alt="upserting example" />
					<li>
						If there is an existing document in the collection that matches the query (name: "Luna" and type: "Cat"),
						its age field will be updated to 3.
					</li>
					<li>
						If there is no existing document matching the query, a new document will be inserted with the specified
						fields (name, type, age).
					</li>
					<li>
						The upsert option is useful when you want to ensure that a document exists or is updated based on certain
						criteria, without explicitly checking for its existence beforehand.
					</li>
				</ul>
			</section>

			<section>
				<h3>Updating Multiple Documents</h3>
				<ul>
					<li>The MongoDB .updateMany() method is used to update multiple documents in a collection simultaneously.</li>
					<li>It allows us to update all documents that satisfy a given condition.</li>
					<img src="./assets/images/updateManySyntax.jpg" alt="update many syntax" />
					<li>The three main parameters are:</li>
					<ol>
						<li>filter: The selection criteria for the update.</li>
						<li>update: The modifications to apply.</li>
						<li>options: Other options that can be applied, such as upsert.</li>
					</ol>
					<img src="./assets/images/updateManyExample.jpg" alt="update many example" />
					<li>This will target all documents with a salary of 75000 and update the salary field to 80000.</li>
					<li>The documents that match the filter will be updated, while others will remain unchanged.</li>
				</ul>
			</section>

			<section>
				<h3>Modifying Documents</h3>
				<ul>
					<li>The .findAndModify() method in MongoDB is used to modify and return a single document.</li>
					<li>By default, the document returned does not include the modifications made on the update.</li>
					<img src="./assets/images/findAndModifySyntax.jpg" alt="find and modify syntax" />
					<li>Four commonly used fields are:</li>
					<ol>
						<li>query: Defines the selection criteria for the record to be modified.</li>
						<li>update: Specifies the fields to update and the changes to make.</li>
						<li>new: When set to true, returns the modified document instead of the original.</li>
						<li>upsert: Creates a new document if the selection criteria does not match any existing documents.</li>
					</ol>
					<li>
						If we want to update a document and see the pre-modification state, we can use the method with the default
						behavior.
					</li>
					<img src="./assets/images/findAndModifydefult.jpg" alt="find and modify defualt" />
					<li>The output of the method will be the document before it was modified, even if the update was applied.</li>
					<li>
						In the second scenario, by setting new: true, the method will return the modified document as the output.
					</li>
					<img src="./assets/images/findAndModifyNewTrue.jpg" alt="find and modify new true" />
					<li>The upsert field allows us to add documents if they don't currently exist in the database.</li>
					<li>If the query does not find a match, the method will create the document based on the upsert option.</li>
					<img src="./assets/images/findAndModifyUpsertTrue.jpg" alt="find and modify upsert true" />
					<li>.updateOne() and .findAndModify() behave similarly but with a key difference:</li>
					<ol>
						<li>.findAndModify() returns the document that was modified, while .updateOne() does not.</li>
						<li>
							Additionally, .findAndModify() allows us to specify whether we want to return the old or new version of
							the updated document using the new parameter.
						</li>
					</ol>
				</ul>
			</section>

			<section>
				<h3>Review: MongoDB CRUD II Inserting & Updating</h3>
				<ul>
					<li>
						The _id field is a unique identifier for documents in a collection. By default, MongoDB assigns an ObjectId
						value to the _id field for each document.
					</li>
					<li>
						Individual documents can be added to a collection with .insertOne(), and the document to be inserted is
						provided as an argument.
					</li>
					<li>
						Multiple documents can be inserted into a collection with the .insertMany() method. An array containing all
						the documents to insert is passed in an argument.
					</li>
					<li>
						The .updateOne() method is used to update the first document within the collection that matches a given
						query.
					</li>
					<li>We can use .updateMany() to update multiple matching documents simultaneously.</li>
					<li>The $push operator appends a specified value to an array.</li>
					<li>
						The .findAndModify() method modifies and returns a single document in a collection. By default, it returns
						the original document, and if no matching document is found, a new one can be inserted by adding the upsert
						option.
					</li>
					<li>
						MongoDB offers us other syntax and commands that can be useful when inserting, updating, or replacing
						documents:
					</li>
					<ol>
						<li>
							The ordered parameter can be provided to the .insertMany() method. It accepts a boolean value, and, if set
							to false, will insert the documents in an unordered format to increase performance.
						</li>
						<li>
							The $unset operator can be provided to the .updateOne() or .updateMany() method. It removes a particular
							field from a document.
						</li>
						<li>
							The .findOneAndUpdate() method is similar to .updateOne(), but instead of returning a document
							acknowledging the success or failure of our operation, it returns either the original or updated document.
						</li>
						<li>
							The .renameCollection() method allows us to update the name of our collection without modifying any of its
							documents.
						</li>
						<li>
							The .bulkWrite() method allows us to perform multiple write operations (updating or inserting) with
							controls for order of execution.
						</li>
					</ol>
				</ul>
				<br />
				<li>
					<a href="https://www.codecademy.com/learn/learn-mongodb/modules/mongo-db-crud-ii/cheatsheet"
						>MongoDB CRUD II - Cheatsheet</a
					>
				</li>
			</section>

			<h2>MongoDB CRUD II Deleting Documents</h2>

			<section>
				<h3>Deleting a Document</h3>
				<ul>
					<li>MongoDB provides the .deleteOne() method to permanently remove a single document from a collection.</li>
					<li>
						To use .deleteOne(), we need to provide specific filtering criteria to identify the document to be deleted.
					</li>
					<img src="./assets/images/DeletingDocumentsSyntax.jpg" alt="deleting documents syntax" />
					<li>Two arguments are passed to .deleteOne():</li>
					<ol>
						<li>filter: A document that specifies the selection criteria for the document to delete.</li>
						<li>
							options: A document that can include optional fields, such as writeConcern, to provide additional
							specifications to the operation.
						</li>
					</ol>
					<img src="./assets/images/DeletingADocument.jpg" alt="deleting a document" />
					<li>
						If the deletion is successful, MongoDB will confirm it with the output: { acknowledged: true, deletedCount:
						1 }.
					</li>
					<img src="./assets/images/DeletingADocumentAcknowledgement.jpg" alt="deleting a documents acknowledgement" />
					<li>
						Only one document matching the criteria will be deleted, even if there are multiple documents with the same
						criteria.
					</li>
					<li>
						The document that gets deleted is determined by factors such as insertion order and the presence of relevant
						indexes.
					</li>
				</ul>
			</section>

			<section>
				<h3>Deleting Multiple Documents</h3>
				<ul>
					<li>
						MongoDB provides the .deleteMany() method to remove multiple documents from a collection based on a given
						filter.
					</li>
					<img src="./assets/images/deleteManySyntax.jpg" alt="delete many syntax" />
					<li>Two arguments are passed to .deleteMany():</li>
					<ol>
						<li>filter: A document that specifies the selection criteria for the documents to delete.</li>
						<li>
							options: A document that can include optional fields, such as writeConcern, to provide additional
							specifications to the operation.
						</li>
					</ol>
					<li>
						If no filter is provided, the .deleteMany() method will delete all documents from the collection, so caution
						should be exercised.
					</li>
					<img src="./assets/images/deleteMany.jpg" alt="delete many example" />
					<li>The operation will delete all documents where the type field has the value of "Hydra".</li>
					<img src="./assets/images/deleteManyAcknowledgement.jpg" alt="delete many acknowledgement" />
					<li>
						After the deletion, the remaining documents in the collection will be those that do not match the deletion
						criteria.
					</li>
				</ul>
			</section>

			<section>
				<h3>Replacing a Document</h3>
				<ul>
					<li>
						MongoDB provides the .replaceOne() method to replace the first document in a collection that matches a given
						filter.
					</li>
					<img src="./assets/images/replaceOneSyntax.jpg" alt="replace one syntax" />
					<li>Three arguments are passed to .replaceOne():</li>
					<ol>
						<li>filter: A document that specifies the selection criteria for the document to replace.</li>
						<li>replacement: The replacement document.</li>
						<li>
							options: A document that can include optional fields, such as upsert, to provide additional specifications
							to the operation.
						</li>
					</ol>
					<li>
						The replacement document can contain a subset of fields from the original document or entirely new fields.
					</li>
					<img src="./assets/images/replaceOneExample.jpg" alt="replace one example" />
					<li>
						The operation will replace the first document that matches the filter criteria with the specified
						replacement document.
					</li>
					<li>
						MongoDB will confirm the success of the operation and provide the output, including the number of matched
						and modified documents.
					</li>
					<li>
						After the replacement, the resulting collection will contain the replaced document with only the fields
						specified in the replacement document, and other fields from the original document will be removed.
					</li>
					<li>
						Unlike the .updateOne() method, which updates specific fields based on update modifiers, .replaceOne()
						replaces the entire document with the specified replacement document.
					</li>
				</ul>
			</section>

			<section>
				<h3>Review: MongoDB CRUD II Deleting Documents</h3>
				<ul>
					<li>
						The .deleteOne() method deletes a single document from a collection. It accepts a filter document specifying
						which document to delete as the first parameter.
					</li>
					<li>The .deleteOne() method will only delete the first matching document in the collection.</li>
					<li>
						The .deleteMany() method deletes all matching documents from a collection. It accepts a filter document
						specifying which document to delete as the first parameter.
					</li>
					<li>
						The .replaceOne() method replaces an entire document from a collection. It takes in filtering criteria
						specifying the document to replace as the first parameter and a replacement document as the second one.
					</li>
					<li>The .replaceOne() method will only replace the first matching document in the collection.</li>
					<li>
						Since .replaceOne() replaces an entire document, only fields included in the second parameter will be
						present in the document after the operation executes.
					</li>
					<li>MongoDB offers us other syntax and commands that can be useful when deleting or replacing documents:</li>
					<ol>
						<li>
							The .findOneAndReplace() method is very similar to .replaceOne(). It replaces a document in a collection
							based on filter criteria, but instead of returning a document that acknowledges the operation, it returns
							either the original document or the replacement document.
						</li>
						<li>The .findOneAndDelete() method deletes a document, and returns the deleted document.</li>
					</ol>
				</ul>
			</section>

			<h2>Indexing in MongoDB</h2>

			<section>
				<h3>What is Indexing?</h3>
				<ul>
					<li>
						Indexing is a tool that makes certain queries in MongoDB more efficient by avoiding the need to search the
						entire database for results.
					</li>
					<li>
						An index is a special data structure that stores a small portion of the collection's data in an
						easy-to-traverse form.
					</li>
					<li>
						It works similarly to an index in a textbook, where you can quickly locate specific information without
						having to scan every page.
					</li>
					<img src="./assets/images/bookIndex.jpg" alt="a book index" />
					<li>
						Indexes in MongoDB aim to optimize query performance and reduce the time, computing power, and cost required
						for queries.
					</li>
					<li>
						Without indexes, queries would need to parse every document in a collection, which becomes inefficient as
						the collection grows in size.
					</li>
				</ul>
			</section>

			<section>
				<h3>The Types of Indexes in MongoDB</h3>
				<ul>
					<li>MongoDB supports several types of indexes to optimize query performance.</li>
					<li>Single-field indexes:</li>
					<ol>
						<li>Indexes only one field of a document.</li>
						<li>Enables querying specific subsets of data.</li>
						<li>Improves query performance by scanning a smaller data set.</li>
						<li>Data is arranged in ascending or descending order for faster matching.</li>
					</ol>
					<img src="./assets/images/sinleFieldIndex.jpg" alt="single field index" />
					<li>Compound indexes:</li>
					<ol>
						<li>Indexes on multiple fields.</li>
						<li>Supports more specific queries with multiple criteria.</li>
						<li>Useful for sorting and organizing data based on multiple fields.</li>
						<li>Enables efficient range-based query operations.</li>
					</ol>
					<li>Multikey indexes:</li>
					<ol>
						<li>Optimized for array fields.</li>
						<li>Indexes each element in the array.</li>
						<li>Automatically created for array fields.</li>
						<li>Compatible with single-field and compound indexes.</li>
					</ol>
				</ul>
			</section>

			<section>
				<h3>Tradeoffs and Precautions When Working with Indexes</h3>
				<ul>
					<li>Indexes are not a one-size-fits-all solution and have some tradeoffs to consider.</li>
					<li>Indexes are most effective for selective queries that retrieve a small portion of the data.</li>
					<li>
						It's important to be conservative and plan ahead when creating indexes due to their space consumption.
					</li>
					<li>
						Indexes improve query performance but impact write performance, as changes to the collection must be
						reflected in each index.
					</li>
					<li>
						Proper planning and consideration of indexes can significantly enhance MongoDB's capabilities and optimize
						query performance.
					</li>
					<li>Indexes help improve computing performance, reduce bandwidth usage, and enhance time efficiency.</li>
				</ul>
			</section>

			<section>
				<h3>Single Field Index</h3>
				<ul>
					<li>
						In MongoDB, indexes improve database performance by storing a small portion of the collection's data in an
						easy-to-traverse form.
					</li>
					<li>
						We can create custom indexes using the .createIndex() method, specifying the keys and optional parameters.
					</li>
					<img src="./assets/images/indexSyntax.jpg" alt="index syntax" />
					<li>
						The keys parameter defines the field and type of the index. Fields can be assigned a value of 1 or -1 for
						ascending or descending order.
					</li>
					<li>
						Creating a single field index involves specifying a field and its sorting order (ascending or descending).
					</li>
					<img src="./assets/images/singleFieldIndex.jpg" alt="single field index" />
					<li>
						By using the indexed field in queries, we can significantly speed up searches, as the index allows for a
						focused scan rather than examining every document in the collection.
					</li>
					<img src="./assets/images/queryingOurIndex.jpg" alt="index query" />
				</ul>
			</section>

			<section>
				<h3>Performance Insights with .explain()</h3>
				<ul>
					<li>
						The .explain() method in MongoDB provides insights into the performance implications of queries,
						particularly regarding indexes.
					</li>
					<li>
						It can be appended to the .find() method and takes a string parameter (verbose) to specify what information
						to explain.
					</li>
					<img src="./assets/images/explainSyntax.jpg" alt="explain syntax" />
					<li>The possible values for verbose are "queryPlanner", "executionStats", and "allPlansExecution".</li>
					<li>
						By using the "executionStats" option, we can gain insights into the execution of the winning query plan for
						a query.
					</li>
					<img src="./assets/images/explainExample.jpg" alt="explain example" />
					<li>
						Running .explain('executionStats') on a query provides detailed information about the operation, including
						metrics such as execution time and the number of documents examined.
					</li>
					<li>The output of .explain() helps us understand how indexes impact query performance.</li>
					<li>
						Comparing the nReturned, totalDocsExamined, and executionTimeMillis fields before and after indexing can
						demonstrate the efficiency gained by using indexes.
					</li>
					<li>
						Indexes can significantly reduce the number of documents examined and improve query execution time,
						particularly when working with large collections.
					</li>
				</ul>
			</section>

			<section>
				<h3>Compound Indexes</h3>
				<ul>
					<li>
						Compound indexes in MongoDB allow us to create indexes that reference multiple fields within a document.
					</li>
					<li>
						The syntax for creating a compound index is similar to that of a single field index, but with multiple
						field-value pairs.
					</li>
					<li>
						The order of the fields in a compound index is important as it determines the sorting order of the index.
					</li>
					<img src="./assets/images/compoundIndexSyntax.jpg" alt="compound index syntax" />
					<li>MongoDB will scan the compound index for matching values and return the corresponding documents.</li>
					<img src="./assets/images/compoundIndexExample.jpg" alt="compoun index example" />
					<li>
						Compound indexes can support queries that match on multiple fields and can also support queries on any
						prefix, or a beginning subset, of the indexed fields.
					</li>
					<li>
						Consider the order of fields in a compound index based on the query patterns to optimize sort operations.
					</li>
					<li>
						Unnecessary indexes can impact write performance, so it's important to evaluate if a compound index would be
						more efficient than creating multiple single field indexes.
					</li>
					<li>Compound indexes automatically get used by MongoDB when querying on the indexed fields.</li>
					<li>
						When creating a compound index, it's important to consider the specific query patterns and the fields
						involved to ensure optimal index usage.
					</li>
				</ul>
			</section>

			<section>
				<h3>Multikey Index on Single Fields</h3>
				<ul>
					<li>
						MongoDB automatically creates a multikey index when an index is created on a field with an array value.
					</li>
					<li>Multikey indexes provide an index key for each element in the indexed array.</li>
					<li>To create a multikey index on a single field, use the same syntax as creating a single-field index.</li>
					<img src="./assets/images/multiKeyIndex.jpg" alt="multikey index" />
					<li>The resulting multikey index contains individual references to each element in the array field.</li>
					<li>Multikey indexes can be used to optimize queries that involve array fields.</li>
					<li>Multikey indexes are compatible with both single field and compound indexes.</li>
				</ul>
			</section>

			<section>
				<h3>Multikey Index on Compound Fields</h3>
				<ul>
					<li>
						Compound multikey indexes are possible in MongoDB, but only one of the indexed fields can have an array as
						its value.
					</li>
					<img src="./assets/images/multikeyIndexCompound.jpg" alt="document with two arrays" />
					<li>
						For example, if we have fields like "sports" and "clubs" with arrays as their values in a document, we can
						create a compound multikey index on either "sports" or "clubs" along with any other field.
					</li>
					<img src="./assets/images/multikeyIndexCompoundExample.jpg" alt="multikey index example" />
					<li>
						However, it is not possible to create a single compound multikey index on both "sports" and "clubs" fields.
					</li>
					<li>
						If we want to index both "sports" and "clubs" fields, we would need to create two separate indexes for them.
					</li>
				</ul>
			</section>

			<section>
				<h3>Deleting an Index</h3>
				<ul>
					<li>It is important to review and remove any unnecessary or redundant indexes to improve performance.</li>
					<li>The .getIndexes() method can be used to see all the indexes associated with a collection.</li>
					<img src="./assets/images/getIndexes.jpg" alt="getIndexes example" />
					<li>
						The .dropIndex() method allows us to remove an index from a collection without modifying the original
						collection.
					</li>
					<li>To delete an index, we need to specify the index name as an argument to the .dropIndex() method.</li>
					<img src="./assets/images/dropIndexExample.jpg" alt="dropIndex example" />
					<li>After deleting an index, we can confirm the removal by using the .getIndexes() method again.</li>
					<li>
						By regularly reviewing and removing unnecessary indexes, we can free up disk space and improve the
						performance of write operations.
					</li>
				</ul>
			</section>

			<section>
				<h3>Review: Indexing in MongoDB</h3>
				<ul>
					<li>
						An index is a data structure that captures a subset of a collection’s data in an easy-to-traverse form. We
						can use the .createIndex() method to create an index.
					</li>
					<li>A single field index is an index that references one field from a document.</li>
					<li>
						We can use the .explain() method with the "executionStats" argument to gain insight into the performance
						implications of our index on our query.
					</li>
					<li>A compound index is an index that contains references to multiple fields within a document.</li>
					<li>
						Multikey indexes are automatically created whenever we create an index on a field that contains an array
						value. Multikey indexes create an index key for each element in the array.
					</li>
					<li>A compound index cannot support two multikey indexes.</li>
					<li>The .dropIndex() method deletes an index without modifying the original collection.</li>
					<li>MongoDB offers us other syntax and commands that can be useful when indexing collections:</li>
					<ol>
						<li>
							Partial Indexes only index documents in a collection that meet specific filter criteria. By indexing a
							subset of a collection’s documents, partial indexes consume less storage and have improved performance.
						</li>
						<li>
							Sparse Indexes only index documents that include the specified index field. Any documents that do not have
							the field will be excluded from the index. Much like partial indexes, these indexes can use significantly
							less storage and have relatively improved performance compared to non-sparse indexes.
						</li>
						<li>
							TTL Indexes are special single-field indexes that MongoDB can use to automatically remove documents from a
							collection after a certain amount of time or at a specific clock time.
						</li>
						<li>
							Unique Indexes enforce unique values for the indexed fields. Creating a unique index on a collection will
							restrict the insertion or update of documents where the indexed field’s value matches an existing value in
							the index.
						</li>
					</ol>
				</ul>
				<p>Useful Links:</p>
				<li>
					<a
						href="https://www.mongodb.com/docs/manual/core/index-partial/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>Partial Indexes</a
					>
				</li>
				<li>
					<a
						href="https://www.mongodb.com/docs/manual/core/index-sparse/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>Sparse Indexes</a
					>
				</li>
				<li>
					<a
						href="https://www.mongodb.com/docs/manual/core/index-ttl/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>TTL Indexes</a
					>
				</li>
				<li>
					<a
						href="https://www.mongodb.com/docs/manual/indexes/#unique-indexes/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral"
						>Unique Indexes</a
					>
				</li>

				<br />
				<li>
					<a href="https://www.codecademy.com/learn/learn-mongodb/modules/indexing-in-mongo-db/cheatsheet"
						>Indexing in MongoDB - Cheatsheet</a
					>
				</li>
			</section>

			<h2>Explore MongoDB Aggregation</h2>

			<section>
				<h3>Introduction</h3>
				<ul>
					<li>Aggregation in MongoDB allows us to perform complex analytical operations on our data.</li>
					<li>It is useful when we want to answer questions related to trends and perform analytics.</li>
					<li>
						Examples of questions that can be answered through aggregation include identifying the best-selling products
						over a specific time period, determining the product with the highest sales on certain days, or finding
						geographic locations that have higher product orders.
					</li>
					<li>
						MongoDB's aggregation framework provides built-in functionality for performing these types of queries.
					</li>
					<li>Aggregation is a core feature of MongoDB and eliminates the need to use separate tools for analytics.</li>
					<li>By utilizing the aggregation framework, we can perform data analysis directly within MongoDB.</li>
				</ul>
			</section>

			<section>
				<h3>Aggregation Basics</h3>
				<ul>
					<li>
						Aggregation in MongoDB involves combining and filtering data in a step-by-step process to derive meaningful
						insights.
					</li>
					<li>
						Aggregation allows us to sift through large amounts of data and perform computations or filtering at each
						step.
					</li>
					<li>
						The primary method for performing aggregation in MongoDB is through the use of an aggregation pipeline.
					</li>
					<li>
						An aggregation pipeline consists of multiple stages, where each stage performs a specific operation on the
						data.
					</li>
					<li>
						The pipeline acts as a channel through which data passes from the start to the end, with each stage
						modifying or filtering the data.
					</li>
					<li>The pipeline can have many stages depending on the analysis requirements.</li>
					<li>
						Creating an aggregation pipeline in MongoDB enables us to manipulate and analyze data in a structured and
						customizable way.
					</li>
					<img src="./assets/images/aggregationPipeline.jpg" alt="aggregation pipeline" />
				</ul>
			</section>

			<section>
				<h3>Getting Started with Aggregation</h3>
				<ul>
					<li>To start using aggregation in MongoDB, we use the .aggregate() method on a collection.</li>
					<img src="./assets/images/aggregationSyntax.jpg" alt="aggregation syntax" />
					<li>The .aggregate() method requires an array of pipeline stages as its argument.</li>
					<li>Each stage in the pipeline performs a specific operation on the data.</li>
					<li>
						A common stage used in aggregation is $match, which filters documents based on a specified field and value.
					</li>
					<img src="./assets/images/aggregationExample.jpg" alt="aggregation example" />
					<li>The $match stage is similar to using the find() method with a query to filter documents.</li>
					<li>The result of the aggregation is a subset of documents that match the specified criteria.</li>
					<li>Building stages in the pipeline allows for complex aggregation operations.</li>
					<li>By adding multiple stages, we can perform more advanced computations and transformations on the data.</li>
					<li>
						As we continue to build our pipeline with different stages, we can explore new stages and enhance our
						understanding of aggregation.
					</li>
				</ul>
			</section>

			<section>
				<h3>Aggregation in Action: Building a Multi-Stage Aggregation Pipeline</h3>
				<ul>
					<li>
						The goal is to create a new collection called "candidates" with specific criteria based on the following
						document.
					</li>
					<img src="./assets/images/document.jpg" alt="document" />
					<li>The criteria for the "candidates" collection are:</li>
					<ol>
						<li>Students must be in the 6th grade.</li>
						<li>Students must have an average test score above 97.</li>
						<li>Students in the new collection must be sorted by their first name.</li>
						<li>
							A new field called "highest_score" needs to be added, containing the highest test score from the
							"test_scores" array.
						</li>
					</ol>
					<li>The aggregation pipeline consists of multiple stages.</li>
					<li>
						The first stage is $match, which filters out students based on the grade level and average test score.
					</li>
					<img src="./assets/images/aggregationMatch.jpg" alt="aggregation match" />
					<li>The second stage is $sort, which sorts the resulting collection by the first name in ascending order.</li>
					<img src="./assets/images/aggregationSort.jpg" alt="aggregation sort" />
					<li>
						The third stage is $addFields, which adds a new field called "highest_score" using the $max operator to find
						the maximum value from the "test_scores" field.
					</li>
					<img src="./assets/images/aggregationAddFieldsSyntax.jpg" alt="aggregation addFields syntax" />
					<img src="./assets/images/aggregationAddFields.jpg" alt="aggregation addFields" />
					<li>
						The fourth stage is $out, which creates a new collection named "candidates" and stores the final aggregation
						result in it.
					</li>
					<img src="./assets/images/aggregationOut.jpg" alt="aggregation out" />
					<li>
						The $out stage can output the final result of an aggregation pipeline to a new database, a new collection,
						or both!
					</li>
				</ul>
			</section>

			<section>
				<h3>When to Use Aggregation</h3>
				<ul>
					<li>
						Aggregation pipelines are used when performing multiple operations together to curate data that is more
						analytical in nature.
					</li>
					<li>Aggregation allows us to see data in a bigger picture and gain insights.</li>
					<li>
						CRUD methods like find() and updateOne() are best for operational tasks, while aggregation is more suitable
						for analytical tasks.
					</li>
					<li>
						Aggregation is useful when there are no CRUD methods or combinations of methods that can easily accomplish
						the desired query.
					</li>
					<li>
						Aggregation is beneficial when performing analysis on datasets, such as grouping values from multiple
						documents, performing computations on data, and analyzing data changes over time.
					</li>
				</ul>
			</section>

			<section>
				<h3>Review: Explore MongoDB Aggregation</h3>
				<ul>
					<li>In MongoDB, we can perform aggregation as an alternative way to query data.</li>
					<li>One way of accomplishing aggregation is by using an aggregation pipeline via the .aggregate() method.</li>
					<li>
						Aggregation pipelines allow us to incrementally filter data through the use of stages, where each stage
						filters/modifies the data in a specific way and then passes that data to the next stage.
					</li>
					<li>We can build a pipeline using stages such as $match or $sort.</li>
					<li>Some stages can utilize different types of expressions such as expression operators like $max.</li>
					<li>
						To reference fields from the documents in our collections inside of expressions, we must use a field path.
					</li>
					<li>
						Aggregation is particularly useful when we have tasks that can’t be accomplished with common CRUD methods
						easily or when we are looking to perform complex analytics on datasets.
					</li>
				</ul>
				<p>Useful Links:</p>
				<li>
					<a href="https://www.mongodb.com/basics/aggregation">MongoDB: Aggregation Basics</a>
				</li>
				<li>
					<a href="https://www.mongodb.com/basics/aggregation-pipeline">MongoDB: Aggregation Pipeline Introduction</a>
				</li>
				<br />
				<li>
					<a href="https://www.codecademy.com/learn/learn-mongodb/modules/explore-mongo-db-extras/cheatsheet"
						>Explore MongoDB - Cheatsheet</a
					>
				</li>
			</section>
		</main>
	</body>
</html>
